---
sectionclass: h2
sectionid: cicd
parent-id: devops
title: Continuous Integration and Continuous Delivery
---

Your development team are making an increasing number of modifications to your application code. It is no longer feasible to manually deploy updates.

You are required to create a robust DevOps pipeline supporting CI/CD to deploy code changes. [Codefresh](https://codefresh.io/features/) is a CI/CD platform that makes working with containers and Kubernetes/Helm very easy. You will use the Codefresh platform to setup pipelines for automated deployments. Codefresh offers free accounts in the cloud, which are fully functional and can be connected with any Git repository and any Kubernetes cluster.

> **Hint**
> Make sure you tokenize the Docker image tags in your Kubernetes YAML configuration files instead of using `latest`. You'll need to set those in the build pipeline to the Build ID.


### Tasks

First you need to sign-up for a Codefresh account (using your git provider as an authentication mechanism)

#### Create a Codefresh account


You can create a free Codefresh account (free forever and fully functional) by signing up at [https://g.codefresh.io/signup](https://g.codefresh.io/signup). You can use any of the supported providers
shown such as Azure or Github.

![Codefresh signup](media/codefresh/codefresh-signup.png)

You will be asked to confirm the permissions requests for your GIT provider. Codefresh does not commit
anything in your GIT repositories (it only reads them to check out code) and the privileges needed are mostly
for automatic triggers (i.e. starting a pipeline when a commit happens).

You will also be asked to provide a username for your Codefresh account. Once that is done you will see the main Codefresh User Interface.


> **Hint**
> Codefresh supports multi-login accounts. You can signup/login with multiple git providers
> and if the email used is the same, you will always reach the same Codefresh account.

For more information see the [create account documentation](https://codefresh.io/docs/docs/getting-started/create-a-codefresh-account/).




#### Fork the source repositories on GitHub 

The repository of the application that you are going to use is located at [https://github.com/todaywasawesome/color-coded/tree/devsecops](https://github.com/todaywasawesome/color-coded/tree/devsecops).

>  **Hint**
>  Make sure you're using the `devsecops` branch.

Login into your Github account and then navigate to the repository URL. Click the *Fork* button on the top right of the
page:

![Fork git repository](media/codefresh/fork-button.png)

Github will start the forking process, so that all files are available to your account as well.

![Import repository to Azure Repos](media/codefresh/forking-process.png)

Once this is finished, you will see a "copy" of the git repository in your own account.

#### Connect your Azure cluster to Codefresh

You will [now connect your Kubernetes](https://codefresh.io/docs/docs/deploy-to-kubernetes/add-kubernetes-cluster/#adding-aks-cluster) cluster in Codefresh. This way
you will extend the pipeline with deployment capabilities in the next section.


Go to your account integrations by selecting *Account Settings* on the left sidebar and then clicking on *Configure* next to "Kubernetes".

![Cluster integrations](media/codefresh/cluster-integrations.png)

From the cluster screen, select "Azure AKS" from the drop-down and authenticate with your Azure account. You will get a new dialog with your subscription and cluster selection:

![Add Azure cluster](media/codefresh/select-cluster.png)

> **Hint**
> You can also add your Azure cluster as a [custom cluster](https://codefresh.io/docs/docs/deploy-to-kubernetes/add-kubernetes-cluster/#adding-any-other-cluster-type-not-dependent-on-any-provider) by selecting *Azure Custom*.

Once the integration is complete, Codefresh will scan the cluster to finds its nodes. To verify the connection
go back to the main Codefresh screen (click on the left arrow on the top left of the screen) and then select *Kubernetes*
from the left sidebar. 

You will see a view of all your namespaces in the cluster.

![View Azure K8s cluster](media/codefresh/view-cluster.png) 


Codefresh is now connected to your cluster. 

> **Hint**
> Make sure to note down the name your cluster as it appears in the dashboard, as you will use it later on in the deployment
pipeline.

#### Connect the Azure Container Registry in Codefresh

The built-in Docker registry that Codefresh offers in all accounts works fine on its own. However, you have already setup secrets in the cluster for the Azure Container registry so it would make sense to change the pipeline to also push images there as well.


In the Codefresh UI, select *Account Settings* on the left sidebar and then click on *Configure* next to [Docker Registry](https://g.codefresh.io/account-admin/account-conf/integration/registry).

![Codefresh Integrations](media/codefresh/integrations.png)

Click the *Add Registry* dropdown and then select *Other Registries*.

Fill in the details for the Azure Container registry registry with the following information:

* Registry name: `myazureregistry` (user defined - lowercase)
* Username: Your service principal ID (called Application/Client Id in your workshop details)
* Password: Your service principal password (called Application Secret Key in your workshop details)
* Domain: `akschallengeXXXXXXXX.azurecr.io`

Where `XXXXXXXX` is the random number assigned to your Docker registry during creation. Use `echo $ACR_NAME` in your cloud shell to find the exact name. 

>  **Hint**
>  If you can't find the url for the registry, goto `https://portal.azure.com/`

![Integrating Azure Registry](media/codefresh/connect-azure-registry.png)

Click the *Test* button to make sure that your credentials are correct and finally the *Save* button to apply your changes.
Codefresh is now connected to your Azure Container registry and can pull images from it.

For more information see the documentation on [external registries](https://codefresh.io/docs/docs/docker-registries/external-docker-registries/) and [custom registries](https://codefresh.io/docs/docs/docker-registries/external-docker-registries/other-registries/).

#### Create our CI/CD pipeline

As a first step for Continuous Integration you will create a pipeline that automatically builds a Docker image
for the sample application, everytime a commit happens.

Go back to your Codefresh account and select *Projects* from the left sidebar. Click *New Project*

Name it `color-coded` and add a tag `devsecops`. You can also pick an icon. Projects are a way to organize pipelines, secrets, permissions and other resources. 

![Create a new project](media/codefresh/create-new-project.png)

Then add a new pipeline called `color-coded`

You will see a repository browser. Make sure that your git provider is selected on the right drop-down menu.

![Select sample repository](media/codefresh/new-pipeline.png)

Click create. Codefresh will generate a new pipeline for us which is very helpful but let's build it up one step at a time. Clear the code there and start with this:

##### Setup Pipeline Stages
```
version: "1"
stages:
  - "build"
  - "test"
  - "deploy"
steps:
```

This will setup our pipeline with 3 stages which we'll use to organize our pipeline. 

##### Add a Git clone step
Next add this code for the Git clone step. Notice that we're using variables like `${{CF_REPO_OWNER}}` which will be filled in automatically by the webhook. 

>  **Hint**
>  Codefresh pipelines use YAML which requires proper indenting.

<<<<<<< HEAD
```

```yaml
{% raw %}
  main_clone:
    title: Cloning main repository...
    type: git-clone
    repo: "${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}"
    revision: "${{CF_REVISION}}"
    stage: build
    repo: '${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}'
    revision: '${{CF_REVISION}}'
    stage: build
{% endraw %} 
```

##### Add build step
The build step uses another built-in step.

>  *Hint*
>  Codefresh uses container-based pipelines which means every single step in a Codefresh pipeine uses separate containers. By default, a shared volume is attached to every step so we can access data between steps. In the previous step, we did a git clone, that code is now available for our build step. 


```yaml
{% raw %}
  build:
    title: "Building Docker Image"
    type: "build"
    image_name: "${{CF_REPO_NAME}}"
    tag: "${{CF_BRANCH_TAG_NORMALIZED}}-${{CF_SHORT_REVISION}}"
    dockerfile: "Dockerfile"
    stage: "build"
{% endraw %}
```

Again, here we make liberal use of variables. 

##### Push image to ACR
Every image we build will be automatically saved in Codefresh's built in registry. We're using ACR for our production registry and so we'll want to promote this image there. 



```yaml
{% raw %}
  push:
    title: "Pushing image to Azure registry"
    type: "push"
    stage: deploy
    image_name: "${{CF_REPO_NAME}}"
    registry: "myazureregistry"
    candidate: "${{build}}"
    tags:
      - "${{CF_BRANCH_TAG_NORMALIZED}}"
      - "${{CF_REVISION}}"
      - "${{CF_BRANCH_TAG_NORMALIZED}}-${{CF_SHORT_REVISION}}"

{% endraw %}
```

For more details see the [Push step documentation](https://codefresh.io/docs/docs/codefresh-yaml/steps/push/).

##### Create pull secret
To pull the image we built and pushed to ACR, we'll need a pull secret. This allows the cluster to pull private images. While this only needs to be done once, you can add this to your pipeline for better portability. 

>  **Hint**
>  Don't forget to replace the cluster name with the one you created.

```yaml
{% raw %}
  createpullsecret:
    image: codefresh/cli
    stage: deploy
    commands:
    - codefresh generate image-pull-secret --cluster [CLUSTER_NAME] --namespace --registry [CODEFRESH_REGISTRY_NAME]
{% endraw %}
```

Because your cluster name will probably has spaces in it name, you should use single quotes around the cluster name. Example of full command:

```
codefresh generate image-pull-secret --cluster 'akschallenge@CloudLabs M12VC - 065' --registry myazureregistry

```

##### Test the pipeline
Save and click run on the pipeline. Make sure to select `devsecops` for your branch. This will build an image, storing it in the Codefresh registry and pushing it into ACR. 

>  **Hint**
>  Both names for cluster and registry correspond to the names you used in the Codefresh integrations page. Visit [Integrations](https://g.codefresh.io/account-admin/account-conf/integration) if you don't remember them.

##### Use Helm to deploy our application
Earlier, we deployed our application using simple Kubernetes manifests. While these YAMLs are easy to use, they become difficult to work with when you need to swap in new values. With Helm, we can use templated manifests and pass in new values at run time. In this case we're versioning our image using the `commit SHA`.

>  **Hint**
>  Replace the `KUBE-CONTEXT` with the name of your AKS cluster you added earlier. 

>  **Hint**
>  The deploy step uses an open source image from the Codefresh steps directory to execute Helm deployments. It's essentially a Docker image with everything it needs to deploy to Helm built in. [Read more about the Helm step](https://steps.codefresh.io/plugin/cfstep-helm) or browse the [https://steps.codefresh.io/](Codefresh steps directory).

>  **Hint**
>  Don't forget to replace the `cluster name` with the one you created.
>  You can find the `image path` by going to `images` in Codefresh, and clicking on the image you created.


```yaml
{% raw %}
  deploy:
    image: codefresh/cfstep-helm:2.9.0
    stage: deploy
    environment:
      - CHART_REF=deploy/helm/colors
      - RELEASE_NAME=color-coded
      - KUBE_CONTEXT=[cluster name]
      - CUSTOM_service.type=LoadBalancer
      - CUSTOM_deployment[0].track=release
      - CUSTOM_deployment[0].image.repository=[image path]
      - CUSTOM_deployment[0].image.tag="${{CF_BRANCH_TAG_NORMALIZED}}-${{CF_SHORT_REVISION}}"
      - CUSTOM_deployment[0].image.version="${{CF_BRANCH_TAG_NORMALIZED}}-${{CF_SHORT_REVISION}}"
      - CUSTOM_deployment[0].image.pullSecret=codefresh-generated-r.cfcr.io-cfcr-${{NAMESPACE}}
<<<<<<< HEAD
{% endraw %}
```
### Build it!

Now that your pipeline is setup, go ahead and click "Run", be sure to select the `devsecops` branch. When you're done your service should be fully deployed. You'll be able to see it in both the [Codefresh Kubernetes view](https://g.codefresh.io/kubernetes/services/), and the [Helm Dashboard](https://g.codefresh.io/helm/releases/releases/). 

>  **Hint**
>  This is a new release from the old service and deployment you started with. It will provision a new ip address and from here on in, we'll only upgrade this service. 

Navigate to one of those views to see the ip address of the service you just deployed and open it to make sure everything is running. 


> **Resources**
> - [Codefresh Registry](https://codefresh.io/docs/docs/docker-registries/codefresh-registry/)
> - [Connecting an external Registry](https://codefresh.io/docs/docs/docker-registries/external-docker-registries/)
> - [Connecting your Kubernetes cluster](https://codefresh.io/docs/docs/deploy-to-kubernetes/add-kubernetes-cluster/)
> - [Managing your cluster](https://codefresh.io/docs/docs/deploy-to-kubernetes/manage-kubernetes/)
> - [Codefresh pipelines](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/introduction-to-codefresh-pipelines/)
> - [Creating pipelines](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/pipelines/)
> - [Codefresh Pipeline YAML](https://codefresh.io/docs/docs/codefresh-yaml/what-is-the-codefresh-yaml/)
> - [Pipeline Steps](https://codefresh.io/docs/docs/codefresh-yaml/steps/)
> - [Custom Kubectl commands](https://codefresh.io/docs/docs/deploy-to-kubernetes/custom-kubectl-commands/)
