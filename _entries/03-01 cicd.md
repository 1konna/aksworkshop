---
sectionclass: h2
sectionid: cicd
parent-id: devops
title: Continuous Integration and Continuous Delivery
---

Your development team are making an increasing number of modifications to your application code. It is no longer feasible to manually deploy updates.

You are required to create a robust DevOps pipeline supporting CI/CD to deploy code changes.

> **Hint** The source code repositories on GitHub contain an [`azure-pipelines.yml`](https://github.com/Azure/azch-captureorder/blob/master/azure-pipelines.yml) definition that you can use with Azure Pipelines to build and deploy the containers. This pipeline is based on the [new multi-stage pipelines](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/) feature of Azure DevOps Pipelines.

### Tasks

#### Create an Azure DevOps account

{% collapsible %}

Go to <https://dev.azure.com> and sign-in with your Azure subscription credentials.

If this is your first time to provision an Azure DevOps account, you'll be taken through a quick wizard to create a new organization.

![Getting started with Azure DevOps](media/cicd/getstarted-devops.png)

{% endcollapsible %}

#### Fork the captureorder project on GitHub

{% collapsible %}

You'll need to work on your own copy of the code. Fork the project [https://github.com/Azure/azch-captureorder/](https://github.com/Azure/azch-captureorder/) on GitHub.

![Fork on GitHub](media/cicd2/01-fork_github.png)

{% endcollapsible %}

#### Create a project on Azure DevOps

{% collapsible %}

Create a new private project, call it **captureorder**

![Create Azure DevOps project](media/cicd2/03-create_project.png)

{% endcollapsible %}

#### Create Docker service connection

Now that you have a project, you need to set it up to authenticate to your Azure Container Registry through a [service connection](https://docs.microsoft.com/en-us/azure/devops/pipelines/library/service-endpoints?view=azure-devops&tabs=yaml#create-new).

{% collapsible %}

Go to your project settings page.

![Project settings](media/cicd2/04.1-project_settings.png)

Open the service connections page from the project settings page and create a new service connection.

![Create a service connection](media/cicd2/04.2-create_service_connection.png)

Add a Docker Registry service connection. Select **Azure Container Registry** and pick your ACR from the list. Name the connection `containerRegistryConnection`.

![Create a service connection](media/cicd2/04.3-create_acr_connection.png)

Due to a [current bug](https://developercommunity.visualstudio.com/content/problem/582809/when-creating-a-docker-registry-service-connection.html), make sure to go to "Policies" and make sure to "allow all pipelines to use this service connection" even if it was checked when you created the connection.

![Allow all pipelines to use this service connection](media/cicd2/04.4-authorize_service_connection.png)

{% endcollapsible %}

#### Create a variable group to hold configuration

Now, instead of hard coding some configuration values and secrets into the pipeline or Kubernetes YAML configuration, you're going to use [variable group](https://docs.microsoft.com/en-us/azure/devops/pipelines/library/variable-groups?view=azure-devops&tabs=yaml) to hold this information.

{% collapsible %}

Go to **Library** and create a new variable group.

![Create variable group](media/cicd2/06-create_variable_group.png)

Name the group `captureorder-variables` and create a `mongoPassword` secret holding your MongoDB password. Make sure to click on the lock icon to designate this a a secret.

![Create mongoPassword](media/cicd2/06.1-create_mongo_password.png)

Afterwards, also add the rest of the variables `mongoHost`, `mongoUser` and `teamName`.

![Create rest of variables](media/cicd2/06.2-create_rest_of_variables.png)

Save and proceed.

{% endcollapsible %}

#### Create an Environment

[Environments](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/environments?view=azure-devops) are a new concept in Azure DevOps Pipelines. An environment represents a collection of resources such as namespaces within Kubernetes clusters, Azure Web Apps, virtual machines, databases, which can be targeted by deployments from a pipeline. Typical examples of environments include Dev, Test, QA, Staging and Production. Currently, only Kubernetes resource type is supported, with the roadmap of environments including support for other resources such as virtual machines, databases and more.

{% collapsible %}

Create your first environment

![Create an environment](media/cicd2/05-create_environments.png)

Create a Kubernetes environment called `aksworkshop`. This will create a Service Principal on your AKS cluster and store it in the service connections.

![Create an aksworkshop environment](media/cicd2/05.1-create_k8s_environment.png)

Select your AKS cluster, and create a new namespace called `dev`

![Create a dev namespace](media/cicd2/05.2-create_namespace.png)

{% endcollapsible %}

#### Create a pipeline

{% collapsible %}

Go back to pipelines and create a new pipeline.

![Create a pipeline](media/cicd2/07-create_pipeline.png)

 Walk through the steps of the wizard by first selecting **GitHub** as the location of your source code.

![Where is your code?](media/cicd2/07-where_is_your_code.png)

You might be redirected to GitHub to sign in. If so, enter your GitHub credentials. When the list of repositories appears, select your repository.

![Select repository](media/cicd2/08-select_repository.png)

You might be redirected to GitHub to install the Azure Pipelines app. If so, select Approve and install.

![Install GitHub app](media/cicd2/09-install_github_app.png)

The source code repository already contains a multi-stage pipeline, which is picked up by the configuration. Inspect the [`azure-pipelines.yml`](https://github.com/Azure/azch-captureorder/blob/master/azure-pipelines.yml) file for the full pipeline. We're relying on a new feature in Azure DevOps which is called "Multi-stage pipelines". [Make sure the Multi-stage pipelines experience is turned on](https://docs.microsoft.com/en-us/azure/devops/project/navigation/preview-features?view=azure-devops_).

![Review pipeline](media/cicd2/10-review_pipeline.png)

The pipeline is broken into two main [stages](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages?view=azure-devops&tabs=yaml):

1. Build
1. Deploy

Each stage then has one or more [jobs](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml), which in turn have one or more [tasks](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/tasks?view=azure-devops&tabs=yaml). A task is the building block for defining automation in a pipeline. A task is simply a packaged script or procedure that has been abstracted with a set of inputs.

##### Inspect the Build stage

The **Build** stage does two things, it uses the [Docker task](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/docker?view=azure-devops) to build an image. It authenticates using the Docker service connection and tags the image with the build number.

```yaml
- task: Docker@2
  displayName: Build and push an image to container registry
  inputs:
    command: buildAndPush
    repository: $(imageRepository)
    dockerfile: '**/Dockerfile'
    containerRegistry: $(dockerRegistryServiceConnection)
    tags: |
      $(tag)
```

It then publishes the [`manifests`](https://github.com/Azure/azch-captureorder/tree/master/manifests) folder, containing the Kubernetes YAML definitions as a pipeline artifact. This is used later in the deployment stage to deploy to Kubernetes.

```yaml
- task: PublishPipelineArtifact@0
  inputs:
    artifactName: 'manifests'
    targetPath: 'manifests'
```

> **Hint**
> - Inspect the YAML files in the **manifests** folder and make sure to replace with your own deployment files.
> - Following best practices, [`deployment.yaml`](https://github.com/Azure/azch-captureorder/blob/master/manifests/deployment.yaml) loads the MongoDB hostname, username and password from a [Kubernetes secret](https://kubernetes.io/docs/concepts/configuration/secret/). Make sure to modify your configuration files to follow the same mechanism.

##### Inspect the Deploy stage

The **Deploy** stage does multiple things. First, it downloads the pipeline artifacts (the manifest folder).

```yaml
- task: DownloadPipelineArtifact@1
  inputs:
    artifactName: 'manifests'
    downloadPath: '$(System.ArtifactsDirectory)/manifests'
```

Then, using the [Kubernetes manifest task](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/kubernetes-manifest?view=azure-devops) `createSecret` action, it creates a Kubernetes secret called `acr-auth` containing the Azure Container Registry Docker configuration. It pulls this configuration from the Docker service connection you created earlier.

```yaml
- task: KubernetesManifest@0
  displayName: Create imagePullSecret from dockerRegistryServiceConnection
  inputs:
    action: createSecret
    secretName: acr-auth # we're going to inject this as an imagePullSecret in the deployment below
    namespace: $(k8sNamespace)
    dockerRegistryEndpoint: $(dockerRegistryServiceConnection)
```

Then, using the same task and the `createSecret` action, it creates a Kubernetes secret holding the MongoDB host, username and password. Note that the `secretArguments` follows the same syntax as when [creating a secret using `kubectl`](https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-a-container-environment-variable-with-data-from-a-single-secret). The values are coming from the variable group you created before.

```yaml
- task: KubernetesManifest@0
  displayName: Create secret for MongoDB
  inputs:
    action: createSecret
    secretName: mongodb
    secretType: generic
    namespace: $(k8sNamespace)
    secretArguments: --from-literal=mongoHost=$(mongoHost) --from-literal=mongoUser=$(mongoUser) --from-literal=mongoPassword=$(mongoPassword)
```

The next task then deploys all the YAML files in the `manifests` folder. It automatically injects the `imagePullSecret` called `acr-auth` into your Kubernetes deployment configuration to enable the cluster to be able to pull images from your Azure Container Registry.

It also automatically overrides the image name you defined in the `deployment.yaml` file to append the current build ID as a tag to the image.

```yaml
- task: KubernetesManifest@0
  displayName: Deploy to Kubernetes cluster
  inputs:
    action: deploy
    namespace: $(k8sNamespace)
    manifests: $(System.ArtifactsDirectory)/manifests/*
    # this automatically injects the imagePullSecret into your Kubernetes deployment configuration
    imagePullSecrets: |
      acr-auth
    containers: |
      $(imageRepository):$(tag)
```

Finally, since we have an environment variable we want to override (in this case `teamName`), the last task [patches](https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/) the deployment to update the environment variable with the value coming from the variable group.

```yaml
- task: KubernetesManifest@0
  displayName: Patch the deployment environment variables
  inputs:
    action: patch
    resourceToPatch: name
    name: $(imageRepository)
    kind: Deployment
    namespace: $(k8sNamespace)
    patch: '{"spec": {"template": {"spec":{"containers":[{"name":"$(imageRepository)","env":[{"name":"TEAMNAME","value":"$(teamName)"}]}]}}}}' # replacing TEAMNAME with the value specified in the variables
```

{% endcollapsible %}

#### Run your pipeline

To save your pipeline, click on **Run**. You will be able to view the status of the pipeline execution.

{% collapsible %}

![Run the pipeline](media/cicd2/11-run_pipeline.png)

The build stage will build the container and push it to Azure Container Registry.

![Build stage](media/cicd2/11.1-build_stage.png)

The deploy stage will create the secrets and deploy the manifests to the `dev` namespace of your AKS cluster.

![Build stage](media/cicd2/11.2-deploy_stage.png)

{% endcollapsible %}

#### Verify environments

If you go back to the environments tab, you should see that your environment has the latest build deployed.

![Verify environments](media/cicd2/12-verify_environments.png)

Click through to the workloads, you should also see the Kubernetes deployment with 2 pods running.

![Verify workload](media/cicd2/12.1-verify_workloads.png)

Click through to the services, you should see the deployed services.

![Verify service](media/cicd2/12.2-verify_service.png)

You can also view the pod logs to make sure that everything is working as planned.

![Verify service](media/cicd2/12.3-pod_logs.png)

> **Resources**
> - [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/environments?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/environments?view=azure-devops)
> - [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema)
> - [https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/?view=azure-devops)