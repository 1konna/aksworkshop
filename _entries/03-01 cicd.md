---
sectionclass: h2
sectionid: cicd
parent-id: devops
title: Continuous Integration and Continuous Delivery
---

Your development team are making an increasing number of modifications to your application code. It is no longer feasible to manually deploy updates.

You are required to create a robust DevOps pipeline supporting CI/CD to deploy code changes. [Codefresh](https://codefresh.io/features/) is a CI/CD solution for containers and Kubernetes/Helm. You will use the Codefresh platform to setup pipelines for automatic deployments. Codefresh offers free accounts in the cloud, which are fully functional and can be connected with any Git repository and any Kubernetes cluster.

> **Hint**
> Make sure you tokenize the Docker image tags in your Kubernetes YAML configuration files instead of using `latest`. You'll need to set those in the build pipeline to the Build ID.




### Tasks

First you need to sign-up for a Codefresh account (using your git provider as an authentication mechanism)

#### Create a Codefresh account

{% collapsible %}

You can create a free Codefresh account (free forever and fully functional) by signing up at [https://g.codefresh.io/signup](https://g.codefresh.io/signup). You can use any of the supported providers
shown such as Azure or Github.

![Codefresh signup](media/codefresh/codefresh-signup.png)

You will be asked to confirm the permissions requests for your GIT provider. Codefresh does not commit
anything in your GIT repositories (it only reads them to check out code) and the privileges needed are mostly
for automatic triggers (i.e. starting a pipeline when a commit happens).

You will also be asked to provide a username for your Codefresh account. Once that is done you will see the main Codefresh User Interface

![Codefresh User Interface](media/codefresh/codefresh-ui.png)


> **Hint**
> Codefresh supports multi-login accounts. You can signup/login with multiple git providers
> and if the email used is the same, you will always reach the same Codefresh account.

For more information see the [create account documentation](https://codefresh.io/docs/docs/getting-started/create-a-codefresh-account/).

{% endcollapsible %}



#### Fork the source repositories on GitHub 

The repository of the application that you are going to use is located at [https://github.com/Azure/azch-captureorder](https://github.com/Azure/azch-captureorder).

{% collapsible %}

Login into your Github account and then navigate to the repository URL. Click the *Fork* button on the top right of the
page:

![Fork git repository](media/codefresh/fork-button.png)

Github will start the forking process, so that all files are available to your account as well.

![Import repository to Azure Repos](media/codefresh/forking-process.png)

Once this is finished, you will see a "copy" of the git repository in your own account.

{% endcollapsible %}

#### Create build pipeline for the application Docker container

As a first step for Continuous Integration you will create a pipeline that automatically builds a Docker image
for the sample application, everytime a commit happens.


{% collapsible %}

Go back to your Codefresh account and select *Repositories* from the left sidebar. Click *Add new repository*

![Add new repository](media/codefresh/add-new.png)

You will see a repository browser. Make sure that your git provider is selected on the right drop-down menu. Type `az`
to filter your repositories and select the sample application.

![Select sample repository](media/codefresh/select-repository.png)

Once the repository is selected Codefresh will ask you on the build method. Select the middle option - Dockerfile.

![Select build method](media/codefresh/build-setup.png)

The sample application already contains a [Dockerfile](https://github.com/Azure/azch-captureorder/blob/master/Dockerfile). Codefresh will detect that and show you the contents for verification:

![Verify Dockerfile](media/codefresh/dockerfile-review.png)

Click *Create* to continue. The final step asks you which branch you want to use for the main build. Leave the default (master) and click *Create Pipeline*.
The Git repository is now successfully added into Codefresh. From now on you can find the project in the main Codefresh Dashboard (repositories)

Codefresh will then present you with the configuration of your pipeline. You will also see an auto-generated `codefresh.yml` pipeline
definition that just builds the docker image. The defaults are fine. Click the *Build* button and confirm your branch selection.

Wait for the pipeline to finish.

![Run Docker pipeline](media/codefresh/build-pipeline.png)


You can click on each individual step to see its logs. Once the pipeline is finished Codefresh will automatically push the Docker
image to the [private Docker registry](https://codefresh.io/docs/docs/docker-registries/codefresh-registry/) that comes built-in to all Codefresh accounts.

Click on *Images* on the left sidebar to inspect your image.

![Docker registry](media/codefresh/codefresh-docker-registry.png)


Congratulations! You now have a basic pipeline that:

1. Checks out your git repository
1. Uses the dockerfile to create a Docker image
1. Pushes the Docker image to a registry


{% endcollapsible %}

#### Create build pipeline for the application Docker container

{% collapsible %}

Save the YAML below as `azure-pipelines.yml` or download it from [azure-pipelines.captureorder.yml](yaml-solutions/devops/azure-pipelines.captureorder.yml) and store it in your code repository (`azch-captureorder`) as `azure-pipelines.yml`

This simply runs `docker build`, `docker login` and `docker push`, tagging the image with the current `BuildId`.

```yaml
pool:
  vmImage: 'Ubuntu 16.04'

variables:
  imageName: 'captureorder:$(Build.BuildId)'
  # define three more variables acrName, dockerId and dockerPassword in the build pipeline in UI

steps:
- script: docker build -f Dockerfile -t $(acrName).azurecr.io/$(imageName) .
  displayName: 'docker build'

- script: docker login -u $(dockerId) -p $(dockerPassword) $(acrName).azurecr.io
  displayName: 'docker login'

- script: docker push $(acrName).azurecr.io/$(imageName)
  displayName: 'docker push'
```

{% endcollapsible %}

#### Build the code in `azch-captureorder` as a Docker image and push it to the Azure Container Registry you provisioned before

{% collapsible %}

Setup a build using YAML pipelines

![Setup build](media/cicd/2-setup-build.png)

Choose YAML as the pipeline template

![Pipeline Config-As-Code](media/cicd/2-config-as-code.png)

Browse to and select the `azure-pipelines.yml` file you created above. You may also change the agent to be `Hosted Ubuntu`

![Select pipeline config file](media/cicd/2-agent-yaml.png)

Define variables in your build pipeline in the web UI:

- `dockerId`: The admin user name/Service Principal ID for the Azure Container Registry.
- `acrName`: The Azure Container Registry name.
- `dockerPassword`: The admin password/Service Principal password for Azure Container Registry.

![Create variable group](media/cicd/2-variable-group.png)

> **Hint:**
> - Refer to <https://docs.microsoft.com/en-us/azure/container-registry/container-registry-auth-aks#access-with-kubernetes-secret> to obtain the Service Principal ID/Service Principal Password or enable the Azure Container Registry admin user.
> - It would be better if you store those variables as a `Variable Group` instead of a `Pipeline Variable`. This will allow you to reuse them across pipelines.

Run the build pipeline and verify that it works

![Build pipeline log](media/cicd/2-build-pipeline-log.png)

Verify that the image ends up in your Azure Container Registry

![Verify images in ACR](media/cicd/2-image-acr.png)

{% endcollapsible %}

#### Create a new Azure DevOps Repo, for example `azch-captureorder-kubernetes` to hold the the YAML configuration for Kubernetes

{% collapsible %}

The reason you're creating a separate repository, is that the Kubernetes deployment configuration is a deployment artifact, which is indepenedent from your code. You may want to change how the container is deployed, which Kubernetes services are created, etc. without triggering a new container build. For this reason, having a seperate repository is the recommended way to go about this, to encourage seperation of concerns. This decouples the application code from where it runs. You build containers in one pipeline but you're not concerned where they would be deployed. You may have multiple other repos and pipelines controlling how you deploy.

Go ahead and create a new repo and call it `azch-captureorder-kubernetes`. Hit the **Initialize** button to create a `README.md` file and add the `.gitignore` file.

![Create a new repo and initialize it](media/cicd/1-create-and-initialize.png)

In the new repository, create a folder `yaml` and add the required YAML files you created before for the service you're building.

![Create YAML folder](media/cicd/1-create-yaml-folder.png)

You may download the YAML files again from the links below. Make sure you store them in the `yaml` folder on the `azch-captureorder-kubernetes` repository.

- [captureorder-deployment.yaml](yaml-solutions/devops/captureorder-deployment.yaml)
- [captureorder-service.yaml](yaml-solutions/devops/captureorder-service.yaml)
- [captureorder-hpa.yaml](yaml-solutions/devops/captureorder-hpa.yaml)

> **Hints**
> - One thing you'll notice is that, in `captureorder-deployment.yaml`, **you'll need to change the image name** `<unique-acr-name>.azurecr.io/captureorder:##BUILD_ID##`. Put in your Azure Container Registry name.
> - Also notice the `##BUILD_ID##`. This is a placeholder that will get replaced further down the line by the release pipeline by the actual version being deployed.

{% endcollapsible %}

#### Create build pipeline for the Kubernetes config files

{% collapsible %}

Save the YAML below as `azure-pipelines.yml` or download it from [azure-pipelines.captureorder-k8s.yml](yaml-solutions/devops/azure-pipelines.captureorder-k8s.yml) and store it in your Kubernetes config repository (`azch-captureorder-kubernetes`) as `azure-pipelines.yml`

This essentially copies the `yaml` folder as a build artifact. The artifact will be picked up by the Release pipeline later on for deployment to the cluster.

```yaml
pool:
  vmImage: 'Ubuntu 16.04'

steps:
- task: PublishBuildArtifacts@1
  displayName: 'publish yaml folder as an artifact'
  inputs:
    artifactName: 'yaml'
    pathToPublish: 'yaml'
```

Similarly to how you setup the Docker images build pipeline, setup a build pipeline using YAML pipelines for `azch-captureorder-kubernetes` repo. Run it once you save and verify you get the `yaml` folder copied as a build artifact.

{% endcollapsible %}

#### Create a continuous deployment pipeline

You'll now create the CD pipeline on the `azch-captureorder-kubernetes` repository that triggers upon **either new container images** or **new YAML configuration artifacts** to deploy the changes to your cluster.

{% collapsible %}

Configure a Service Connection so that Azure DevOps can access resources in your Azure Resource Group for deployment and configuration purposes

![Create Service Connection](media/cicd/3-create-service-connection.png)

Pick the Azure Resource Group you're using

![Pick Azure RG for Service Connection](media/cicd/3-resource-group-service-connection.png)

Create a Release Pipeline, start with an Empty template. Add an **Azure Container Registry** artifact as a trigger and enable the continuous deployment trigger. Make sure to configure it to point to the Azure Container Registry repository where the build pipeline is pushing the `captureorder` image

![ACR artifact trigger](media/cicd/3-artifact.png)

Add another Build artifact coming from the `azch-captureorder-kubernetes` pipeline as a trigger and enable the continuous deployment trigger. This is the trigger for changes in the YAML configuration.
> **Hint** Make sure to pick the *kubernetes* build pipeline and not your main code build pipeline. Also make sure you select *Latest* as the default version

![Build artifact trigger](media/cicd/3-artifact-2.png)

Now, start adding tasks to the default stage. Make sure the agent pool is **Hosted Ubuntu 1604** then add an *inline* **Bash Script** task that will do a token replacement to replace `##BUILD_ID##` in the `captureorder-deployment.yaml` file coming from the with the actual build being released. Remember that `captureorder-deployment.yaml` was published as a build artifact.

You'll want to get the Docker container tag incoming from the Azure Container Registry trigger to replace the `##BUILD_ID##` token. If you named that artifact **_captureorder**, the build number will be in an environment variable called `RELEASE_ARTIFACTS__CAPTUREORDER_BUILDNUMBER`. Similarly for the other artifact **_azch-captureorder-kubernetes**, its build ID would be stored in `RELEASE_ARTIFACTS__AZCH-CAPTUREORDER-KUBERNETES-CI_BUILDID`. You can use the following inline script that uses the `sed` tool.

```sh
sed "s/##BUILD_ID##/${RELEASE_ARTIFACTS__CAPTUREORDER_BUILDNUMBER}/g" "$SYSTEM_ARTIFACTSDIRECTORY/_azch-captureorder-kubernetes-CI/yaml/captureorder-deployment.yaml"
```

![Bash task](media/cicd/3-bash-task.png)

Add a **Deploy to Kubernetes** task. Configure access to your AKS cluster using the service connection created earlier.

Scroll down and check **Use configuration files** and use the following value `$(System.DefaultWorkingDirectory)/_azch-captureorder-kubernetes-CI/yaml/captureorder-deployment.yaml` or select it from the browse button.

![Kubernetes task](media/cicd/3-kubernetes-task-browse.png)

> **Hint** Do the same for `captureorder-service.yaml` and `captureorder-hpa.yaml`. You can right click on the Kubernetes task and clone it.

Once you're done, you should have the tasks looking like the following.

![Kubernetes task](media/cicd/3-kubernetes-task.png)

Create a manual release and pick the latest build as the source. Verify the release runs and that the `captureorder` service is deployed

![Create a release](media/cicd/3-create-release.png)

{% endcollapsible %}

#### Verify everything works

{% collapsible %}

1. Make a change to the application source code, commit the change and watch the pipelines build and release the new version.

1. Make a change to the configuration (for example, change the number of replicas), commit the change and watch the pipelines update your configuration.

![CI/CD release in progress](media/cicd/4-cicd-release.png)

```sh
kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
captureorder-64b49756b6-8df8p      1/1     Running   0          55s
captureorder-64b49756b6-fjk9d      1/1     Running   0          56s
captureorder-64b49756b6-rrhck      1/1     Running   0          59s
captureorder-64b49756b6-vscn7      1/1     Running   0          1m
```

{% endcollapsible %}

> **Resources**
> - [https://docs.microsoft.com/en-us/azure/devops/pipelines/apps/cd/deploy-aks?view=vsts](https://docs.microsoft.com/en-us/azure/devops/pipelines/apps/cd/deploy-aks?view=vsts)
> - [https://docs.microsoft.com/en-us/azure/aks/jenkins-continuous-deployment](https://docs.microsoft.com/en-us/azure/aks/jenkins-continuous-deployment)
> - [https://docs.microsoft.com/en-us/azure/jenkins/jenkins-aks-blue-green-deployment](https://docs.microsoft.com/en-us/azure/jenkins/jenkins-aks-blue-green-deployment)
> - <https://docs.microsoft.com/en-us/azure/devops/pipelines/languages/docker?view=vsts&tabs=yaml>
> - <https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/build-artifacts?view=vsts&tabs=yaml>
> - <https://damianbrady.com.au/2018/10/11/what-yaml-do-i-need-for-azure-pipelines/>
> - <https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>